# Story 8.3: Pipeline IPC + Preload

## Goal

Wire up all pipeline IPC handlers in the main process and expose them via the preload script. Handle content activation (PTY switching + file watcher restart).

## Dependencies

- Story 8.1 (pipeline module)
- Story 8.2 (worktree module)

## Files to Edit

```
src/main/ipc.ts                        # Update: register pipeline:* IPC handlers
src/main/preload.cjs                   # Update: add pipeline namespace
```

## IPC Channels

| Channel | Type | Purpose |
|---------|------|---------|
| `pipeline:list` | invoke | List all pipeline items |
| `pipeline:create` | invoke | Create new content (folder + metadata + worktree) |
| `pipeline:updateStage` | invoke | Update stage in metadata.json |
| `pipeline:updateMetadata` | invoke | Partial update to metadata.json |
| `pipeline:readMetadata` | invoke | Read metadata.json |
| `pipeline:activate` | invoke | Activate content piece (switch PTY, restart watcher) |
| `pipeline:getActive` | invoke | Get currently active content piece |
| `pipeline:contentChanged` | push | Notify renderer of pipeline changes |

## Activation Flow (`pipeline:activate`)

1. Store `activeContent = item`
2. If item has `worktreePath`: call `changePtyDirectory(worktreePath)`
3. Restart file watcher on the active content's directory
4. If worktree: watch `<worktreePath>/content/`
5. If no worktree: watch `<projectRoot>/content/`

## Content Creation Flow (`pipeline:create`)

1. Call `createContentPiece()` from pipeline module
2. If project is git repo: call `createWorktree()`, update metadata with branch/path
3. Activate the new content piece (PTY switch + watcher)
4. Type starter prompt into PTY (no Enter â€” let user complete):
   - LinkedIn: `"Create a LinkedIn post about "`
   - Blog: `"Write a blog post about "`
   - Newsletter: `"Create a newsletter about "`
5. Emit `pipeline:contentChanged` to renderer
6. Return the PipelineItem

## Metadata Change Detection

Subscribe to file watcher events. When `metadata.json` changes, emit `pipeline:contentChanged` to renderer so sidebar refreshes.

## Preload (`src/main/preload.cjs`)

Add `pipeline` namespace following existing patterns:
```javascript
pipeline: {
  listPipelineItems: () => ipcRenderer.invoke('pipeline:list'),
  createContent: (type) => ipcRenderer.invoke('pipeline:create', type),
  updateStage: (metadataPath, stage) => ipcRenderer.invoke('pipeline:updateStage', metadataPath, stage),
  updateMetadata: (metadataPath, metadata) => ipcRenderer.invoke('pipeline:updateMetadata', metadataPath, metadata),
  readMetadata: (metadataPath) => ipcRenderer.invoke('pipeline:readMetadata', metadataPath),
  activateContent: (item) => ipcRenderer.invoke('pipeline:activate', item),
  getActiveContent: () => ipcRenderer.invoke('pipeline:getActive'),
  onPipelineChanged: (callback) => {
    const listener = () => callback()
    ipcRenderer.on('pipeline:contentChanged', listener)
    return () => ipcRenderer.removeListener('pipeline:contentChanged', listener)
  },
},
```

## Cleanup

Add `removeHandler` calls for all pipeline handlers in `mainWindow.on('closed')`.

## Acceptance Criteria

- [ ] All pipeline IPC handlers registered and functional
- [ ] pipeline:create creates content + worktree + activates + types starter prompt
- [ ] pipeline:activate switches PTY directory and restarts file watcher
- [ ] pipeline:contentChanged emitted when metadata.json changes
- [ ] Preload exposes complete pipeline API
- [ ] Cleanup on window close removes all handlers
